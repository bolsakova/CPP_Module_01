==========================
 Stack vs Heap allocation
==========================

STACK:
	- когда объект нужен только внутри функции
	- объект автоматически удаляется при выходе из функции

HEAP:
	- когда объект должен "пережить" функцию
	- объект живет до тех пор, пока не вызвать delete

============================================
 INITIALIZATION LIST (список инициализации)
============================================
	- это специальный синтаксис С++ для инициализации членов класса ДО выполнения тела конструктора.
1. Синтаксис:

	Конструктор(параметры) : член1(значение1), член2(значение2), член3(значение3) {
		// тело конструктора
	}
2. Когда initailization list обязателен?

	- const члены
	- ссылки
3. Порядок инициализации

	ВАЖНО! Атрибуты инициализируются в порядке их ОБЪЯВЛЕНИЯ В КЛАССЕ, а не в порядке а списке!

======
 THIS
======
	- это указатель на текущий объект, к-рый автоматически доступен внутри любого нестатического метода класса
Тип:			указатель на объект класса
Значение:		адрес текущего объекта в памяти
Доступность:	автоматически доступен в любом методе класса
1. Синтаксис:
	this->атрибут	(доступ к атрибуту через указатель)
	(*this).атрибут	(альтернативный синтаксис и реже используется)
2. Основные применения:
	- разрешение конфликта имен (если и атрибут класса, и параметр функции одинаково названы)
	- возврат ссылки на себя
	  пример: Zombie& setName(std::string name) {
				this->name = name;
				return *this;		(вовзвращаем сслку на текущий объект)
			}
	- передача себя в другую функцию
	  пример: void someMethod() {
				someFunction(this);	(передаем указатель на себя)
			}

======================
 ADDRESS MANIPULATION
======================
1. Переменная
	- это "коробка" в памяти, к-рая содержит значение
	- имеет свой адрес в памяти
	- &variable
2. Указатель
	- это "стрелка", к-рая показывает на адрес другой переменной
	- сам указатель тоже занимает место в памяти
	- std::string *ptr
	- (1) может быть пустым, (2) затем присваивается адрес
	  std::string* stringPTR;	(1)
	  stringPTR = &string;		(2)
3. Ссылка
	- это "псевдоним" (другое имя) для существующей переменной
	- не занимает дополнительного места в памяти
	- std::string& ref
	- обязательная инициализация при объявлении (должна быть инициализирована сразу!)
	  std::string& stringREF = string;
	- нельзя переприсвоить другой переменной
	- всегда валидна (не может быть NULL)
Пример:
	Представим, что у тебя есть дом (переменная)
		адрес дома - это где он находится в памяти
		указатель - это записка с адресом дома
		ссылка - это второе имя для того же дома
Вывод:
	Указатель и ссылка - это просто разные способы обращения к той эе самой переменной в памяти!
Указатель vs Ссылка:
	ссылка		- когда объект всегда есть и не меняется
	указатель	- когда объект может отсутствовать или меняться

=========
 FSTREAM
=========
	- это библиотека в С++ для работы с файлами.
	  fstream - file stream (файловый поток)
Что в себя включает?
	1. std::ifstream (input file stream)
		назначение: чтение из файла
		аналогия: как std::cin, но из файла
		пример: открыть текстовый файл и прочитать его содержимое
	2. std::ofstream (output file stream)
		назначение: запись в файл
		аналогия: как std::cout, но в файл
		пример: создать новый файл и записать в него текст
	3. std::fstream (file stream)
		назначение: чтение и запись в один файл
		использование: когда нужно и читать, и писать в тот же файл
Потоки (Streams):
	Поток - это "труба" для данных
	Входной поток - данные идут ОТ источника К программе
	Выходной поток - данные идут ОТ программы К назначению
		Источник -> Труба -> Программа -> Труба -> Назначение
		Файл -> ifstream -> C++ -> ofstream -> файл
Как работать с fstream?
Основной паттерн:
	1. Создать поток
	   	std::ifstream inputFile("filename.txt");
	2. Проверить открылся ли файл
	   if (!inputFile) {
			std::cout << "Ошибка открытия файла!" << std::endl;
			return 1;
	   }
	3. Работать с файлом
	   std::string line;
	   while (std::getline(inputFile, line)) {
			std::cout << line << std::endl;
	   }
	4. Файл закроется автоматически при выходе из области видимости
Где и когда используется?
	- чтение конфигурационных файлов
	- логирование (запись логов)
	- обработка данных из файлов
	- создание отчетов
	- резервное копирование настроек
Преимущества:
	- автоматическое закрытие файлов
	- безопасность типов
	- интеграция с std::string
	- исключения для обработки ошибок

==============================
 POINTERS TO MEMBER FUNCTIONS
==============================
Синтаксис указателя на метод класса:
	void (<class>::*methodPtr)(void) = &<class>::<method>;
Вызов через указатель:
	(this->*methodPtr)();
