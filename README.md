Stack vs Heap allocation

STACK:
	- когда объект нужен только внутри функции
	- объект автоматически удаляется при выходе из функции

HEAP:
	- когда объект должен "пережить" функцию
	- объект живет до тех пор, пока не вызвать delete

INITIALIZATION LIST (список инициализации):
	- это специальный синтаксис С++ для инициализации членов класса ДО выполнения тела конструктора.
1. Синтаксис:

	Конструктор(параметры) : член1(значение1), член2(значение2), член3(значение3) {
		// тело конструктора
	}
2. Когда initailization list обязателен?

	- const члены
	- ссылки
3. Порядок инициализации

	ВАЖНО! Атрибуты инициализируются в порядке их ОБЪЯВЛЕНИЯ В КЛАССЕ, а не в порядке а списке!

THIS:
	- это указатель на текущий объект, к-рый автоматически доступен внутри любого нестатического метода класса
Тип:			указатель на объект класса
Значение:		адрес текущего объекта в памяти
Доступность:	автоматически доступен в любом методе класса
1. Синтаксис:

	this->атрибут	(доступ к атрибуту через указатель)
	(*this).атрибут	(альтернативный синтаксис и реже используется)
2. Основные применения:
	- разрешение конфликта имен (если и атрибут класса, и параметр функции одинаково названы)
	- возврат ссылки на себя
	  пример: Zombie& setName(std::string name) {
				this->name = name;
				return *this;		(вовзвращаем сслку на текущий объект)
			}
	- передача себя в другую функцию
	  пример: void someMethod() {
				someFunction(this);	(передаем указатель на себя)
			}

ADDRESS MANIPULATION:
1. Переменная
	- это "коробка" в памяти, к-рая содержит значение
	- имеет свой адрес в памяти
	- &variable
2. Указатель
	- это "стрелка", к-рая показывает на адрес другой переменной
	- сам указатель тоже занимает место в памяти
	- std::string *ptr
	- (1) может быть пустым, (2) затем присваивается адрес
	  std::string* stringPTR;	(1)
	  stringPTR = &string;		(2)
3. Ссылка
	- это "псевдоним" (другое имя) для существующей переменной
	- не занимает дополнительного места в памяти
	- std::string& ref
	- обязательная инициализация при объявлении (должна быть инициализирована сразу!)
	  std::string& stringREF = string;
	- нельзя переприсвоить другой переменной
	- всегда валидна (не может быть NULL)
Пример:
	Представим, что у тебя есть дом (переменная)
		адрес дома - это где он находится в памяти
		указатель - это записка с адресом дома
		ссылка - это второе имя для того же дома
Вывод:
	Указатель и ссылка - это просто разные способы обращения к той эе самой переменной в памяти!
