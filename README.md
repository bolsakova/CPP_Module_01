==========================
 Stack vs Heap allocation
==========================

STACK:
	- когда объект нужен только внутри функции
	- объект автоматически удаляется при выходе из функции

HEAP:
	- когда объект должен "пережить" функцию
	- объект живет до тех пор, пока не вызвать delete

============================================
 INITIALIZATION LIST (список инициализации)
============================================
	- это специальный синтаксис С++ для инициализации членов класса ДО выполнения тела конструктора.

1. Синтаксис:

	Конструктор(параметры) : член1(значение1), член2(значение2), член3(значение3) {
		// тело конструктора
	}
2. Когда initailization list обязателен?

	- const члены
	- ссылки
3. Порядок инициализации

	ВАЖНО! Атрибуты инициализируются в порядке их ОБЪЯВЛЕНИЯ В КЛАССЕ, а не в порядке а списке!

======
 THIS
======
	- это указатель на текущий объект, к-рый автоматически доступен внутри любого нестатического метода класса

Тип:			указатель на объект класса
Значение:		адрес текущего объекта в памяти
Доступность:	автоматически доступен в любом методе класса

1. Синтаксис:
	this->атрибут	(доступ к атрибуту через указатель)
	(*this).атрибут	(альтернативный синтаксис и реже используется)
2. Основные применения:
	- разрешение конфликта имен (если и атрибут класса, и параметр функции одинаково названы)
	- возврат ссылки на себя
	  пример: Zombie& setName(std::string name) {
				this->name = name;
				return *this;		(вовзвращаем сслку на текущий объект)
			}
	- передача себя в другую функцию
	  пример: void someMethod() {
				someFunction(this);	(передаем указатель на себя)
			}

======================
 ADDRESS MANIPULATION
======================
1. Переменная
	- это "коробка" в памяти, к-рая содержит значение
	- имеет свой адрес в памяти
	- &variable
2. Указатель
	- это "стрелка", к-рая показывает на адрес другой переменной
	- сам указатель тоже занимает место в памяти
	- std::string *ptr
	- (1) может быть пустым, (2) затем присваивается адрес
	  std::string* stringPTR;	(1)
	  stringPTR = &string;		(2)
3. Ссылка
	- это "псевдоним" (другое имя) для существующей переменной
	- не занимает дополнительного места в памяти
	- std::string& ref
	- обязательная инициализация при объявлении (должна быть инициализирована сразу!)
	  std::string& stringREF = string;
	- нельзя переприсвоить другой переменной
	- всегда валидна (не может быть NULL)

Пример:
	Представим, что у тебя есть дом (переменная)
		адрес дома - это где он находится в памяти
		указатель - это записка с адресом дома
		ссылка - это второе имя для того же дома

Вывод:
	Указатель и ссылка - это просто разные способы обращения к той же самой переменной в памяти!

Указатель vs Ссылка:
	ссылка		- когда объект всегда есть и не меняется
	указатель	- когда объект может отсутствовать или меняться

=========
 FSTREAM
=========
	- это библиотека в С++ для работы с файлами.
	  fstream - file stream (файловый поток)

Что в себя включает?
	1. std::ifstream (input file stream)
		назначение: чтение из файла
		аналогия: как std::cin, но из файла
		пример: открыть текстовый файл и прочитать его содержимое
	2. std::ofstream (output file stream)
		назначение: запись в файл
		аналогия: как std::cout, но в файл
		пример: создать новый файл и записать в него текст
	3. std::fstream (file stream)
		назначение: чтение и запись в один файл
		использование: когда нужно и читать, и писать в тот же файл

Потоки (Streams):
	Поток - это "труба" для данных
	Входной поток - данные идут ОТ источника К программе
	Выходной поток - данные идут ОТ программы К назначению
		Источник -> Труба -> Программа -> Труба -> Назначение
		Файл -> ifstream -> C++ -> ofstream -> файл

Как работать с fstream?

Основной паттерн:
	1. Создать поток
	   	std::ifstream inputFile("filename.txt");
	2. Проверить открылся ли файл
	   if (!inputFile) {
			std::cout << "Ошибка открытия файла!" << std::endl;
			return 1;
	   }
	3. Работать с файлом
	   std::string line;
	   while (std::getline(inputFile, line)) {
			std::cout << line << std::endl;
	   }
	4. Файл закроется автоматически при выходе из области видимости

Где и когда используется?
	- чтение конфигурационных файлов
	- логирование (запись логов)
	- обработка данных из файлов
	- создание отчетов
	- резервное копирование настроек

Преимущества:
	- автоматическое закрытие файлов
	- безопасность типов
	- интеграция с std::string
	- исключения для обработки ошибок

==============================
 POINTERS TO MEMBER FUNCTIONS
==============================
Указатель на метод - переменная, к-рая хранит адрес метода класса.

- Обычный указатель на функцию:
	int (*funcPtr)() = &someFunction;

- Синтаксис указателя на метод класса:
	void (<class>::*methodPtr)(void) = &<class>::<method>;

- Вызов через указатель:
	(this->*methodPtr)();

- Объявление указателя на метод класса
	void (<class>::*<pointer_name>)(void);
	
this		: текущий объект
->*			: оператор вызова метода через указатель
::*			: оператор указателя на метод
methods[i]	: указатель на нужный метод
()			: вызов метода
(void)		: параметры метода

==================
 SWITCH STATEMENT
==================
	- конструкция для выбора одного из множества вариантов на основе      	значения переменной.

1. Базовый синтаксис:
	switch (variable) {
		case VALUE1:
			// код для VALUE1
			break;
		case VALUE2:
			// код для VALUE2
			break;
		default:
			// код по умолчанию
			break;
	}
2. Особенность switch - "fall through":
	switch (level) {
		case 1:
			std::cout << "Level 1" << std::endl;
			// НЕТ break! - выполнение продолжится вниз
		case 2:
			std::cout << "Level 2" << std::endl;
			break;
		case 3:
			std::cout << "Level 3" << std::endl;
			break;
	}
3. Проблема:
	- switch работает только с числами, не со строками
